#!/bin/sh

# helper functions from
# https://gitlab.com/kayg/sh-helpers

# run_cmd(): run commands while suppressing both the output and error streams
# and displaying a user-friendly tick or cross.
#
# use:
#   run_cmd cmd
run_cmd() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # if ${logfile} is UNSET or EMPTY, set the value to the string "/dev/null"
    local output_stream="${logfile:-/dev/null}"
    local error_stream="${logfile:-/dev/null}"

    if ${@} 1>"${output_stream}" 2>"${error_stream}"; then
        printf " \u2714\n"
    else
        printf " \u274c\n"
        exit 1
    fi
}

# run_cmd_with_log(): run commands while redirecting STDOUT and STDERR and
# displaying a user-friendly tick or cross after the displayed message.
#
# use:
#   run_cmd logfile cmd
run_cmd_with_log() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # get the absolute path of the first argument provided, i.e the file to log
    # stdout and stderr to
    logfile="$(realpath ${1})"

    # shift parameters by 1 to the right
    # $1=a $2=b $3=c
    #
    # become:
    #
    # $1=b $2=c $3=
    shift 1

    # reuse code in the run_cmd function
    run_cmd "${@}"
}

# status(): display a tick if the last command succeeded or a cross if the last
# command failed. this is done by cheching the exit code, which if non-zero
# indicates erroneous exit. basically, a drop-in replacement for `run_cmd()`
# where it cannot be used, for example: commands that need to be run with `sudo`
# or `doas`.
#
# use:
#   status
status() {
    if [ "${?}" == "0" ]; then
        printf " \u2714\n"
    else
        printf " \u274c\n"
        exit 1
    fi
}

# script local variables
script_path="$(dirname $(realpath -s ${0}))"

# zsh
zsh_src="${script_path}/zsh/.config/zsh"
zsh_dest_zsh="${HOME}/.config/zsh"
zsh_dest_omz="${zsh_dest_zsh}"
zsh_dest_custom_themes="${HOME}/.config/zsh/custom/themes"
zsh_dest_custom_plugins="${HOME}/.config/zsh/custom/plugins"
zsh_plugins="
    https://github.com/zsh-users/zsh-history-substring-search
    https://github.com/zsh-users/zsh-syntax-highlighting
    https://github.com/zsh-users/zsh-completions
    https://github.com/zsh-users/zsh-history-substring-search
"

setup_zsh() {
    if [ -d "${zsh_dest_zsh}" ]; then
       printf '%s' "${zsh_dest_zsh} exists, which indicates a previous installation. Please remove this directory and run the setup again."
       exit 1
    fi

    # delete any files in /etc/zsh
    printf '%s' "[Needs Root Permissions] Deleting files in /etc/zsh"
    sudo rm --force --recursive /etc/zsh/*

    # copy zshenv to /etc/zsh
    printf '%s' "[Needs Root Permissions] Copying zshenv to /etc/zsh"
    sudo cp "${script_path}/zsh/etc/zsh/zshenv" "/etc/zsh"

    # install oh-my-zsh
    printf '%s' "Installing oh-my-zsh"
    run_cmd git clone "https://github.com/ohmyzsh/ohmyzsh.git" "${zsh_dest_omz}"

    # install plugins for zsh
    printf '%s\n' 'Setting up plugins for ZSH'
    for plugin in ${zsh_plugins}; do
        printf '%s' "  Cloning ${plugin}"
        run_cmd git -C "${zsh_dest_custom_plugins}" clone "${plugin}"
    done

    # installing powerlevel10k
    printf '%s' 'Installing powerlevel10k'
    run_cmd git -C "${zsh_dest_custom_themes}" clone --depth=1 https://github.com/romkatv/powerlevel10k.git

    # linking configuration
    printf '%s' 'Linking personal configuration'
    run_cmd ln -sf "${zsh_src}/.zshrc" "${zsh_dest_zsh}"
}

update_zsh() {
    printf '%s' 'Updating oh-my-zsh'
    run_cmd git -C "${zsh_dest_custom_plugins}/${plugin}" pull

    printf '%s' 'Updating plugins'
    for plugin in "${zsh_dest_custom_plugins}"/*; do
        run_cmd git -C "${zsh_dest_custom_plugins}/${plugin}" pull
    done
}

main() {
    # check if sudo or doas are installed
    if ! command doas 2>/dev/null && ! command -v sudo 2>/dev/null; then
        printf '%s' 'Neither sudo nor doas are installed. Please install either application to continue.'
        exit 1
    elif command doas 2>/dev/null; then
        alias sudo=doas
    fi


    ${1}_${2}
}

main "${@}"

exit 0
