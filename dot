#!/bin/sh

# helper functions from
# https://gitlab.com/kayg/sh-helpers

# same as -e
# exit immediately if command exits with a non-zero status
set -o errexit
# same as -u
# treat unset variables as error when substituting
set -o nounset
# the return value of a pipeline is the status of the last command to exit with
# a non-zero status
set -o pipefail

# check_if_installed(): as the name implies, check if a program is installed. if
# it is, continue, otherwise exit with non-zero status.
check_if_installed() {
    if ! command -v "${1}" 2>/dev/null 1>&2; then
        printf '%s\n' "${1} is not installed. Please install ${1} to continue."
        exit 1
    fi
}

# run_cmd(): run commands while suppressing both the output and error streams
# and displaying a user-friendly tick or cross.
#
# use:
#   run_cmd cmd
run_cmd() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # if ${logfile} is UNSET or EMPTY, set the value to the string "/dev/null"
    local output_stream="${logfile:-/dev/null}"
    local error_stream="${logfile:-/dev/null}"

    if ${@} 1>"${output_stream}" 2>"${error_stream}"; then
        printf " \u2714\n"
    else
        printf " \u274c\n"
        exit 1
    fi
}

# run_cmd_with_log(): run commands while redirecting STDOUT and STDERR and
# displaying a user-friendly tick or cross after the displayed message.
#
# use:
#   run_cmd logfile cmd
run_cmd_with_log() {
    if [ -z "${1}" ]; then
        printf '%s' "No arguments provided. Exiting."
        exit 1
    fi

    # get the absolute path of the first argument provided, i.e the file to log
    # stdout and stderr to
    logfile="$(realpath ${1})"

    # shift parameters by 1 to the right
    # $1=a $2=b $3=c
    #
    # become:
    #
    # $1=b $2=c $3=
    shift 1

    # reuse code in the run_cmd function
    run_cmd "${@}"
}

# status(): display a tick if the last command succeeded or a cross if the last
# command failed. this is done by cheching the exit code, which if non-zero
# indicates erroneous exit. basically, a drop-in replacement for `run_cmd()`
# where it cannot be used, for example: commands that need to be run with `sudo`
# or `doas`.
#
# use:
#   status
status() {
    if [ "${?}" == "0" ]; then
        printf " \u2714\n"
    else
        printf " \u274c\n"
        exit 1
    fi
}

# script local variables
script_path="$(dirname $(realpath -s ${0}))"

# emacs
emacs_src="${script_path}/emacs/.config/doom"
doom_dest="${HOME}/.config/doom"
emacs_dest="${HOME}/.config/emacs"

setup_emacs() {
    if [ -d "${doom_dest}" ] && [ -d "${emacs_dest}" ]; then
        printf '%s\n' "an existing doom emacs configuration already exists."
        printf '%s\n' "please remove ${doom_dest} and ${emacs_dest} to continue."
        exit 1
    fi

    printf '%s' "Creating necessary directories"
    run_cmd mkdir -p "${doom_dest}" && mkdir -p "${emacs_dest}"

    printf '%s' "Cloning Doom Emacs"
    run_cmd git clone --depth=1 "https://github.com/hlissner/doom-emacs" "${emacs_dest}"

    printf '%s\n' "Installing Doom Emacs"
    "${emacs_dest}/bin/doom" install

    printf '%s' "Linking the doom executable in ${HOME}/.local/bin"
    run_cmd mkdir -p "${HOME}/.local/bin" && ln -sf "${emacs_dest}/bin/doom" "${HOME}/.local/bin"

    printf '%s' "Linking personal configuration"
    run_cmd ln -sf "${emacs_src}"/* "${doom_dest}"

    printf '%s' "Syncing Doom Emacs to the linked configuration"
    "${emacs_dest}/bin/doom" sync
}

update_emacs() {
    "${emacs_dest}/bin/doom" upgrade
}

# tmux
tmux_src="${script_path}/tmux"
tmux_dest="${HOME}/.tmux"

setup_tmux() {
    printf '%s' "Cloning oh-my-tmux"
    run_cmd git clone "https://github.com/gpakosz/.tmux.git" "${tmux_dest}"

    printf '%s' "Linking personal configuration"
    run_cmd ln -sf "${tmux_dest}/.tmux.conf" "${HOME}" && ln -sf "${tmux_src}/.tmux.conf.local" "${HOME}"
}

update_tmux() {
    printf '%s' "Updating oh-my-tmux repo"
    run_cmd git --git-dir="${tmux_dest}/.git" --work-tree="${tmux_dest}" pull
}

# zsh
zsh_src="${script_path}/zsh/.config/zsh"
zsh_dest_zsh="${HOME}/.config/zsh"
zsh_dest_omz="${zsh_dest_zsh}"
zsh_dest_custom_themes="${HOME}/.config/zsh/custom/themes"
zsh_dest_custom_plugins="${HOME}/.config/zsh/custom/plugins"
zsh_plugins="
    https://github.com/zsh-users/zsh-autosuggestions
    https://github.com/zsh-users/zsh-completions
    https://github.com/zsh-users/zsh-history-substring-search
    https://github.com/zsh-users/zsh-syntax-highlighting
"

setup_zsh() {
    if [ -d "${zsh_dest_zsh}" ]; then
       printf '%s' "${zsh_dest_zsh} exists, which indicates a previous installation. Please remove this directory and run the setup again."
       exit 1
    fi

    # delete any files in /etc/zsh
    printf '%s' "[Needs Root Permissions] Deleting files in /etc/zsh"
    sudo rm --force --recursive /etc/zsh/*

    # copy zshenv to /etc/zsh
    printf '%s' "[Needs Root Permissions] Copying zshenv to /etc/zsh"
    sudo cp "${script_path}/zsh/etc/zsh/zshenv" "/etc/zsh"

    # install oh-my-zsh
    printf '%s' "Installing oh-my-zsh"
    run_cmd git clone "https://github.com/ohmyzsh/ohmyzsh.git" "${zsh_dest_omz}"

    # install plugins for zsh
    printf '%s\n' 'Setting up plugins for ZSH'
    for plugin in ${zsh_plugins}; do
        printf '%s' "  Cloning ${plugin}"
        run_cmd git -C "${zsh_dest_custom_plugins}" clone "${plugin}"
    done

    # installing powerlevel10k
    printf '%s' 'Inrnetmrsentrsnemrsnermnerstalling powerlevel10k'
    run_cmd git -C "${zsh_dest_custom_themes}" clone --depth=1 https://github.com/romkatv/powerlevel10k.git

    # linking configuration
    printf '%s' 'Linking personal configuration'
    run_cmd ln -sf "${zsh_src}/.zshrc" "${zsh_dest_zsh}"
}

update_zsh() {
    printf '%s' 'Updating oh-my-zsh'
    run_cmd git -C "${zsh_dest_custom_plugins}/${plugin}" pull

    printf '%s' 'Updating plugins'
    for plugin in "${zsh_dest_custom_plugins}"/*; do
        run_cmd git -C "${zsh_dest_custom_plugins}/${plugin}" pull
    done
}

main() {
    # check if sudo or doas are installed
    if ! command -v doas 2>/dev/null 1>&2 && ! command -v sudo 2>/dev/null 1>&2; then
        printf '%s' 'Neither sudo nor doas are installed. Please install either application to continue.'
        exit 1
    elif command doas 2>/dev/null; then
        alias sudo=doas
    fi


    check_if_installed "${2}"
    ${1}_${2}
}

main "${@}"

exit 0
