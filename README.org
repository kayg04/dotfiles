#+TITLE: README
#+AUTHOR: K Gopal Krishna
#+PROPERTY: header-args :cache yes :mkdirp yes

* Bootstrap
#+BEGIN_SRC sh :tangle dot :shebang "#!/usr/bin/env bash"
  # import sanity
  set -euo pipefail

  # global declarations
  SCRIPT_PATH=$(dirname $(realpath "$0"))
  ZSH="${HOME}/.config/omz"
  ZSH_CUSTOM="${HOME}/.config/omz/custom"

  update() {
      case "${1}" in
          "desktop")
              updateDesktop
              ;;
          "doom"|"emacs")
              updateEmacs
              ;;
          "firefox")
              updateFirefox
              ;;
          "plasma")
              updatePlasma
              ;;
          "spotify")
              updateSpotify
              ;;
          "systemd")
              updateSystemd
              ;;
          "thunderbird")
              updateThunderbird
              ;;
          "chromium")
              updateChromium
              ;;
          "utilsh")
              updateUtilsh
              ;;
          "zsh")
              updateZSH
              ;;
      esac
  }

  updateDesktop() {
      ln -sf "${SCRIPT_PATH}"/.local/share/applications/*.desktop "${HOME}"/.local/share/applications/
  }

  updateEmacs() {
      ln -sf "${SCRIPT_PATH}"/.config/doom/* "${HOME}"/.config/doom/
      "${HOME}"/.emacs.d/bin/doom refresh
  }

  updateFirefox() {
      source "${SCRIPT_PATH}"/.mozilla/firefox/bootstrap.sh

      applyPolicies
      applyProfilesINI
      updateUserJS
      applyUserJS
      cleanUp
  }

  updatePlasma() {
      ln -sf "${SCRIPT_PATH}"/.config/autostart-scripts/*.sh "${HOME}"/.config/autostart-scripts/
      ln -sf "${SCRIPT_PATH}"/.config/plasma-workspace/env/*.sh "${HOME}"/.config/plasma-workspace/env/
      ln -sf "${SCRIPT_PATH}"/.pam_environment "${HOME}"/
  }

  updateSystemd() {
      ln -sf "${SCRIPT_PATH}"/.config/systemd/user/*.service "${HOME}"/.config/systemd/user/

      for service in $(ls -1 "${HOME}/.config/systemd/user" | cut -d '.' -f1); do
          systemctl --user enable --now "${service}"
      done
  }

  updateThunderbird() {
      ln -sf "${SCRIPT_PATH}"/.thunderbird/profiles.ini "${HOME}"/.thunderbird/
  }

  updateVSCodium() {
      ln -sf "${SCRIPT_PATH}"/.config/VSCodium/User/*.json "${HOME}"/.config/VSCodium/User/
  }

  updateChromium() {
      ln -sf "${SCRIPT_PATH}"/.config/chromium-flags.conf "${HOME}"/.config/
  }

  updateUtilsh() {
      ln -sf "${SCRIPT_PATH}"/.local/bin/* "${HOME}"/.local/bin/
  }

  updateZSH() {
      if [[ ! -d "${ZSH_CUSTOM}"/plugins/zsh-syntax-highlighting ]]; then
          git clone https://github.com/zsh-users/zsh-syntax-highlighting.git "${ZSH_CUSTOM:-~/.oh-my-zsh/custom}"/plugins/zsh-syntax-highlighting
      fi

      if [[ ! -d "${ZSH_CUSTOM}"/plugins/zsh-autosuggestions ]]; then
          git clone https://github.com/zsh-users/zsh-autosuggestions "${ZSH_CUSTOM:-~/.oh-my-zsh/custom}"/plugins/zsh-autosuggestions
      fi

      ln -sf "${SCRIPT_PATH}"/.zshrc "${HOME}"/
  }

  setup() {
      case "${1}" in
          "desktop")
              setupDesktop
              ;;
          "doom"|"emacs")
              setupEmacs
              ;;
          "firefox")
              setupFirefox
              ;;
          "plasma")
              setupPlasma
              ;;
          "spotify")
              setupSpotify
              ;;
          "systemd")
              setupSystemd
              ;;
          "thunderbird")
              setupThunderbird
              ;;
          "chromium")
              setupChromium
              ;;
          "utilsh")
              setupUtilsh
              ;;
          "zsh")
              setupZSH
              ;;
      esac
  }

  setupDesktop() {
      mkdir -p "${HOME}"/.local/share/applications
      updateDesktop
  }

  setupEmacs() {
      echo -e "Creating doom emacs directory..."
      if mkdir -p "${HOME}"/.config/doom; then
          printf '\u2714\n'
      else
          printf '\u274c\n'
      fi

      echo -ne "Cloning doom emacs source..."
      if git clone https://github.com/hlissner/doom-emacs ~/.emacs.d; then
          printf '\u2714\n'
      else
          printf '\u274c\n'
      fi

      echo -e "Unleashing doom..."
      "${HOME}"/.emacs.d/bin/doom install

      updateEmacs
  }

  setupFirefox() {
      source "${SCRIPT_PATH}"/.mozilla/firefox/bootstrap.sh

      applyPolicies
      createProfilesINIDir
      applyProfilesINI
      createProfiles
      updateUserJS
      applyUserJS
      cleanUp
      startFirefox
  }

  setupPlasma() {
      updatePlasma
  }

  setupSpotify() {
      source "${SCRIPT_PATH}"/.config/spotify/wmname.sh

      # fix wm name setting
      fetchSource
      buildLibrary
      moveLibrary
      fixSpotify
  }

  setupSystemd() {
      mkdir -p "${HOME}/.config/systemd/user"
  }

  setupThunderbird() {
      mkdir -p "${HOME}"/.config/thunderbird/primary
      updateThunderbird
  }

  setupVSCodium() {
      updateVSCodium
  }

  setupChromium() {
      updateChromium
  }

  setupUtilsh() {
      updateUtilsh
  }

  setupZSH() {
      if [[ ! upgrade_oh_my_zsh || ! -d "${HOME}/.oh-my-zsh" ]]; then
          export ZSH="${HOME}/.config/omz"
          sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
      else
          exit 1
      fi
  }

  addToPath() {
      echo -e "Adding this program to \$PATH so that it is globally available."
      mkdir -p "${HOME}"/.local/bin
      ln -sf "${SCRIPT_PATH}"/dot "${HOME}"/.local/bin/
  }

  refresh() {
      git --git-dir="${SCRIPT_PATH}/.git" --work-tree="${SCRIPT_PATH}" pull
  }

  main() {
      case "${1}" in
          "setup")
              setup "${2}"
              ;;
          "update")
              update "${2}"
              ;;
          "set")
              addToPath
              ;;
          "refresh")
              refresh
              ;;
          ,*)
              echo -e "Invalid option."
              ;;
      esac
  }

  main "${@}"
#+END_SRC
* Autostart
** Scripts
*** SSH
#+BEGIN_SRC sh :tangle .config/autostart-scripts/ssh-add.sh :shebang "#!/usr/bin/env bash"
  # Enable extended globbing
  shopt -s extglob dotglob nullglob

  # Add all files in $HOME/.ssh/keys that do not end
  # with .pub
  ssh-add "${HOME}"/.ssh/keys/!(*.pub) </dev/null
#+END_SRC
* Desktop
** Invidious
#+BEGIN_SRC conf :tangle .local/share/applications/invidious.desktop :shebang "#!/usr/bin/env xdg-open"
  [Desktop Entry]
  Name=Invidious
  StartupNotify=true
  Icon=/home/kayg/Pictures/Icons/youtube.png
  Comment=Most popular video streaming platform
  Exec=chromium --user-data-dir=${HOME}/.config/chromium/Apps --app=https://tube.kayg.org/
  Terminal=false
  Type=Application
  MimeType=x-scheme-handler/youtube;
  StartupWMClass=invidious
  Categories=Audio;Music;Player;AudioVideo;
#+END_SRC
** Riot
#+BEGIN_SRC conf :tangle .local/share/applications/riot.desktop :shebang "#!/usr/bin/env xdg-open"
  [Desktop Entry]
  Name=Riot
  Comment=A feature-rich client for Matrix.org
  Exec=chromium --user-data-dir=${HOME}/.config/chromium/Apps --app=https://riot.im/app/
  Terminal=false
  Type=Application
  Icon=/home/kayg/Pictures/Icons/riot.png
  StartupWMClass="Riot"
  Categories=Network;InstantMessaging;Chat;IRCClient
#+END_SRC
** Slack
#+BEGIN_SRC conf :tangle .local/share/applications/slack.desktop :shebang "#!/usr/bin/env xdg-open"
  [Desktop Entry]
  Name=Slack
  StartupWMClass=Slack
  Comment=Where work happens
  GenericName=Slack Desktop
  Exec=chromium --user-data-dir=${HOME}/.config/chromium/Apps --app=https://iiit-bhcoding.slack.com/
  Icon=slack
  Terminal=false
  Type=Application
  MimeType=x-scheme-handler/slack;
  StartupNotify=true
  Categories=GNOME;GTK;Network;InstantMessaging;
#+END_SRC
* Emacs
After an year of configuring Emacs, I have somehow reached
exactly at a point which mimics the style and philosophy of
Doom Emacs without realizing it. Although my configuration
was, at heart, a doomacs; in performance and functionality,
it lagged behind by a significant margin.

I have found myself frustrated by the fact that I have to
bake in functionality of every kind when I'm in /need/ of
that particular functionality, and hence, a lot of time was
spent in adding functionality rather than being creative or
productive. My first train of thought was to try something
which abstracted all of this functionality into a single
click -- something like VSCodium -- but the problem with
that particular editor is it isn't particularly hackable.
Apart from a hundred or so rants about how lacking VSCodium
is to my pal [[https://pandacowbat.com][Anwes]], one particular thing that irked me a lot
was the incessant need to reach for the mouse for something
or the other. I would have to change the whole keyboard
shortcuts layout to customize it to my needs and what was
worse is that I would have to remember two of those layouts
-- one which worked with the vim emulation and one which
worked with native VSCodium -- and the latter doesn't even
support three key chord bindings at the time of writing
this.

What VSCodium excels at, though, is the autocompletion,
intellisense, /almost/ baked-in like support for linting,
checking, debugging. LSP is a first class citizen in
VSCodium and VSCodium is the first (and perhaps the only?)
editor that LSP is tested on. All of this makes LSP on
something like Emacs a slow, tedious hog; adding further
disappointment given the time taken to configure it.

The solution -- or perhaps -- the best balance that I could
find was in **doom** (pun intended). Doom Emacs (for now, at
least) seems to do everything I need, OOTB; has a
trouble-free way of adding language support. So I am
throwing away (or refactoring?) my 1 year-in-the-making
configuration of Emacs to find my peace in doom.
** Init
#+BEGIN_SRC emacs-lisp :tangle .config/doom/init.el
  ;;; init.el -*- lexical-binding: t; -*-

  ;; Copy this file to ~/.doom.d/init.el or ~/.config/doom/init.el ('doom install'
  ;; will do this for you). The `doom!' block below controls what modules are
  ;; enabled and in what order they will be loaded. Remember to run 'doom refresh'
  ;; after modifying it.
  ;;
  ;; More information about these modules (and what flags they support) can be
  ;; found in modules/README.org.

  (doom! :input
         ;;chinese
         ;;japanese

         :completion
         company           ; the ultimate code completion backend
         ;;helm              ; the *other* search engine for love and life
         ;;ido               ; the other *other* search engine...
         ivy               ; a search engine for love and life

         :ui
         ;;deft              ; notational velocity for Emacs
         doom              ; what makes DOOM look the way it does
         doom-dashboard    ; a nifty splash screen for Emacs
         doom-quit         ; DOOM quit-message prompts when you quit Emacs
         ;;fill-column       ; a `fill-column' indicator
         hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
         ;;hydra
         indent-guides     ; highlighted indent columns
         modeline          ; snazzy, Atom-inspired modeline, plus API
         nav-flash         ; blink the current line after jumping
         ;;neotree           ; a project drawer, like NERDTree for vim
         ophints           ; highlight the region an operation acts on
         (popup            ; tame sudden yet inevitable temporary windows
          +all             ; catch all popups that start with an asterix
          +defaults)       ; default popup rules
         ;;pretty-code       ; replace bits of code with pretty symbols
         tabs              ; an tab bar for Emacs
         treemacs          ; a project drawer, like neotree but cooler
         ;;unicode           ; extended unicode support for various languages
         vc-gutter         ; vcs diff in the fringe
         vi-tilde-fringe   ; fringe tildes to mark beyond EOB
         window-select     ; visually switch windows
         workspaces        ; tab emulation, persistence & separate workspaces

         :editor
         (evil +everywhere); come to the dark side, we have cookies
         file-templates    ; auto-snippets for empty files
         ;;god               ; run Emacs commands without modifier keys
         fold              ; (nigh) universal code folding
         ;;(format +onsave)  ; automated prettiness
         ;;lispy             ; vim for lisp, for people who dont like vim
         multiple-cursors  ; editing in many places at once
         ;;objed             ; text object editing for the innocent
         ;;parinfer          ; turn lisp into python, sort of
         rotate-text       ; cycle region at point between text candidates
         snippets          ; my elves. They type so I don't have to
         ;;word-wrap         ; soft wrapping with language-aware indent

         :emacs
         dired             ; making dired pretty [functional]
         electric          ; smarter, keyword-based electric-indent
         ibuffer           ; interactive buffer management
         vc                ; version-control and Emacs, sitting in a tree

         :term
         eshell            ; a consistent, cross-platform shell (WIP)
         ;;shell             ; a terminal REPL for Emacs
         ;;term              ; terminals in Emacs
         vterm             ; another terminals in Emacs

         :tools
         ;;ansible
         ;;debugger          ; FIXME stepping through code, to help you add bugs
         ;;direnv
         ;;docker
         ;;editorconfig      ; let someone else argue about tabs vs spaces
         ;;ein               ; tame Jupyter notebooks with emacs
         eval              ; run code, run (also, repls)
         (flycheck          ; tasing you for every semicolon you forget
          +childframe)
         ;;flyspell          ; tasing you for misspelling mispelling
         ;;gist              ; interacting with github gists
         (lookup           ; helps you navigate your code and documentation
          +docsets)        ; ...or in Dash docsets locally
         lsp
         ;;macos             ; MacOS-specific commands
         magit             ; a git porcelain for Emacs
         ;;make              ; run make tasks from Emacs
         ;;pass              ; password manager for nerds
         ;;pdf               ; pdf enhancements
         ;;prodigy           ; FIXME managing external services & code builders
         ;;rgb               ; creating color strings
         ;;terraform         ; infrastructure as code
         ;;tmux              ; an API for interacting with tmux
         ;;upload            ; map local to remote projects via ssh/ftp
         ;;wakatime

         :lang
         ;;agda              ; types of types of types of types...
         ;;assembly          ; assembly for fun or debugging
         (cc                ; C/C++/Obj-C madness
          +lsp)
         ;;clojure           ; java with a lisp
         ;;common-lisp       ; if you've seen one lisp, you've seen them all
         ;;coq               ; proofs-as-programs
         ;;crystal           ; ruby at the speed of c
         ;;csharp            ; unity, .NET, and mono shenanigans
         data              ; config/data formats
         ;;erlang            ; an elegant language for a more civilized age
         ;;elixir            ; erlang done right
         ;;elm               ; care for a cup of TEA?
         emacs-lisp        ; drown in parentheses
         ;;ess               ; emacs speaks statistics
         ;;faust             ; dsp, but you get to keep your soul
         ;;fsharp           ; ML stands for Microsoft's Language
         (go                ; the hipster dialect
          +lsp)
         (haskell +intero) ; a language that's lazier than I am
         ;;hy                ; readability of scheme w/ speed of python
         ;;idris             ;
         ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
         ;;javascript        ; all(hope(abandon(ye(who(enter(here))))))
         ;;julia             ; a better, faster MATLAB
         ;;kotlin            ; a better, slicker Java(Script)
         ;;latex             ; writing papers in Emacs has never been so fun
         ;;lean
         ;;ledger            ; an accounting system in Emacs
         ;;lua               ; one-based indices? one-based indices
         markdown          ; writing docs for people to ignore
         ;;nim               ; python + lisp at the speed of c
         nix               ; I hereby declare "nix geht mehr!"
         ;;ocaml             ; an objective camel
         (org              ; organize your plain life in plain text
          +dragndrop       ; drag & drop files/images into org buffers
          ;+hugo            ; use Emacs for hugo blogging
          +ipython         ; ipython/jupyter support for babel
          +pandoc          ; export-with-pandoc support
          ;+pomodoro        ; be fruitful with the tomato technique
          +present)        ; using org-mode for presentations
         ;;perl              ; write code no one else can comprehend
         ;;php               ; perl's insecure younger brother
         ;;plantuml          ; diagrams for confusing people more
         ;;purescript        ; javascript, but functional
         (python            ; beautiful is better than ugly
          +lsp)
         ;;qt                ; the 'cutest' gui framework ever
         ;;racket            ; a DSL for DSLs
         ;;rest              ; Emacs as a REST client
         ;;ruby              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
         (rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
          +lsp)
         ;;scala             ; java, but good
         ;;scheme            ; a fully conniving family of lisps
         (sh                ; she sells {ba,z,fi}sh shells on the C xor
          +lsp)
         ;;solidity          ; do you need a blockchain? No.
         ;;swift             ; who asked for emoji variables?
         ;;terra             ; Earth and Moon in alignment for performance.
         ;;web               ; the tubes

         :email
         ;;(mu4e +gmail)       ; WIP
         ;;notmuch             ; WIP
         ;;(wanderlust +gmail) ; WIP

         ;; Applications are complex and opinionated modules that transform Emacs
         ;; toward a specific purpose. They may have additional dependencies and
         ;; should be loaded late.
         :app
         ;;calendar
         ;;irc               ; how neckbeards socialize
         ;;(rss +org)        ; emacs as an RSS reader
         ;;twitter           ; twitter client https://twitter.com/vnought
         ;;(write            ; emacs for writers (fiction, notes, papers, etc.)
         ;; +wordnut         ; wordnet (wn) search
         ;; +langtool)       ; a proofreader (grammar/style check) for Emacs

         :config
         ;; For literate config users. This will tangle+compile a config.org
         ;; literate config in your `doom-private-dir' whenever it changes.
         ;;literate

         ;; The default module sets reasonable defaults for Emacs. It also
         ;; provides a Spacemacs-inspired keybinding scheme and a smartparens
         ;; config. Use it as a reference for your own modules.
         (default +bindings +smartparens))
#+END_SRC
** Config
- Set theme & font based on the hostname
- Do not preserve indentation while tangling code blocks.
- Use child frames instead of sideline
- Modified LSP UI settings for better visibility
  - UI Doc should display longer but fewer lines
  - UI Doc should show up under cursor rather than at bottom or top
  - Since UI Doc child frame overlaps the line, it is visually helpful to
    include the header.
  - UI Doc child frame should have a different font which is smaller so as to
    fit more text
- 'jk' should cause NORMAL state regardless of the order the keys are typed in
#+BEGIN_SRC emacs-lisp :tangle .config/doom/config.el
  (after! org
    (setq org-src-preserve-indentation nil)
    (setq org-hide-emphasis-markers t))

  (after! lsp-ui
    (setq lsp-ui-sideline-enable nil)
    (setq lsp-ui-doc-enable t)
    (setq lsp-ui-doc-position 'at-point)
    (setq lsp-ui-doc-header t)
    (setq lsp-ui-doc-max-height 6)
    (setq lsp-ui-doc-max-width 54))

  (add-hook 'lsp-ui-doc-frame-hook
            (lambda (frame _w)
              (set-face-attribute 'default frame :font "Fira Mono" :height 132)))

  (setq treemacs-width 25)
  (setq evil-escape-unordered-key-sequence t)

  (when (string= (system-name) "ruri")
    (setq doom-theme 'doom-outrun-electric)
    (setq doom-font (font-spec :family "IBM Plex Mono" :size 28 :weight 'semi-bold)
          doom-variable-pitch-font (font-spec :family "Fira Sans") ; inherits `doom-font''s :size
          doom-unicode-font (font-spec :family "Input Mono Narrow" :size 26)
          doom-big-font (font-spec :family "IBM Plex Mono" :size 44 :weight 'semi-bold)))

  (when (string= (system-name) "nana")
    (setq doom-theme 'doom-dracula)
    (setq doom-font (font-spec :family "SF Mono" :size 22 :weight 'semi-bold)
          doom-variable-pitch-font (font-spec :family "Fira Sans") ; inherits `doom-font''s :size
          doom-unicode-font (font-spec :family "Input Mono Narrow" :size 18)
          doom-big-font (font-spec :family "SF Mono" :size 36 :weight 'semi-bold)))
#+END_SRC
** Packages
Add extra packages
#+BEGIN_SRC emacs-lisp :tangle .config/doom/packages.el
  (package! caddyfile-mode)
  (package! command-log-mode)
  (package! dockerfile-mode)
  (package! docker-compose-mode)
#+END_SRC
* Firefox
** Profiles
- =StartWithLastProfile= ensures a profile choice isn't
  asked at startup.

Sometimes Firefox amazes me by how customizable it is. I
have +two+ three profiles with Firefox; one for browsing,
one for /research/ and one for web applications. Since a lot
of my research gets lost and I'm unable to refer to previous
findings, it helps to have a separate profile. All profiles
are stored in a standardized XDG configuration directory
(=~/.config/firefox=) rather than the default
(=~/.mozilla/firefox/=). I would also rather name my own
profiles than let firefox name them randomly.

+I tried running Electron Apps with it but sadly, things+
+like pasting images from clipboard and downloading files+
+from Skype (yes, my workplace uses *Skype* in 2019, *groan*)+
+do not work. Hence I now rely on Ungoogled Chromium to do my+
+dirty work.+

+I tried using ungoogled chromium for dirty web apps but+
+recently, on Arch Linux, =libjsoncpp= got an update and+
+broke chromium which isn't as regularly built as the+
+upstream binaries. So though, clipboard interaction was a+
+sweet feature to have, I can let it go for relatively good+
+stability.+

Ungoogled Chromium works again!

Although things work fine with UC, I'm unsure if Chromium
profiles actually provide a /temporary-container/ sort of
isolation. I say this because tabs on different profiles
show up as normal tabs in the task manager which would mean
that an application running on one profile is externally
aware. Please correct me on this if you have more
information. I also miss the declarative configuration that
Firefox offers as I reinstall often.
#+BEGIN_SRC ini :tangle .mozilla/firefox/profiles.ini
  [General]
  StartWithLastProfile=1

  [Profile0]
  Name=Browse
  IsRelative=1
  Path=../../.config/firefox/browse
  Default=1

  [Profile1]
  Name=Research
  IsRelative=1
  Path=../../.config/firefox/research
  Default=0
#+END_SRC
** Policies
Mozilla's Policies' explanation can be found [[https://github.com/mozilla/policy-templates/blob/master/README.md][here]].
#+BEGIN_SRC json :tangle .mozilla/firefox/policies.json
  {
    "policies": {
      "CaptivePortal": true,
      "Cookies": {
        "Default": true,
        "AcceptThirdParty": "never",
        "ExpireAtSessionEnd": false
      },
      "DisableAppUpdate": true,
      "DisableDeveloperTools": false,
      "DisableFeedbackCommands": true,
      "DisableFirefoxAccounts": false,
      "DisableFirefoxScreenshots": true,
      "DisableFirefoxStudies": true,
      "DisableMasterPasswordCreation": true,
      "DisablePocket": true,
      "DisableProfileImport": false,
      "DisableSetDesktopBackground": false,
      "DisableSystemAddonUpdate": true,
      "DisableTelemetry": true,
      "DNSOverHTTPS": {
        "Enabled": true,
        "ProviderURL": "https://dns.quad9.net/dns-query",
        "Locked": false
      },
      "Extensions": {
        "Install": [
                     "https://addons.mozilla.org/firefox/downloads/latest/bitwarden-password-manager/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/canvasblocker/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/clearurls/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/decentraleyes/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/httpz/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/invidition/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/multi-account-containers/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/temporary-containers/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/ublock-origin/latest.xpi",
                     "https://addons.mozilla.org/firefox/downloads/latest/umatrix/latest.xpi"
                   ],
        "Uninstall": [
                       "amazondotcom@search.mozilla.org",
                       "bing@search.mozilla.org",
                       "ebay@search.mozilla.org",
                       "google@search.mozilla.org",
                       "twitter@search.mozilla.org"
                 ],
        "Locked":  [""]
      },
      "ExtensionUpdate": true,
      "HardwareAcceleration": true,
      "NetworkPrediction": false,
      "NoDefaultBookmarks": true,
      "OfferToSaveLogins": false,
      "SanitizeOnShutdown": {
          "Cache": true,
          "Cookies": false,
          "Downloads": false,
          "FormData": false,
          "History": false,
          "Sessions": true,
          "SiteSettings": false,
          "OfflineApps": true
      },
      "SearchBar": "unified",
      "SSLVersionMin": "tls1.2"
    }
  }
#+END_SRC
** UserJS
*** General
I use GHacks' UserJS which I think is an excellent beginner
point towards making your own customizations as it allows
you to focus on tweaking for usablity from an already
privacy-centered configuration.
#+BEGIN_SRC js :tangle .mozilla/firefox/user-overrides.js
  /// GPU Acceleration ///

  // Force enable hardware acceleration
  user_pref("layers.acceleration.force-enabled", true);
  // WebRender is automatically disabled for screens < 4K
  user_pref("gfx.webrender.all", true);
  // Enable accelerated azure canvas
  user_pref("gfx.canvas.azure.accelerated", true);

  /// GPU Acceleration ///

  /// Storage ///

  // Do caching in RAM instead of disk
  user_pref("browser.cache.disk.enable", false);
  user_pref("browser.cache.memory.enable", true);

  // Save session data every 5 minutes instead of every 15 seconds
  user_pref("browser.sessionstore.interval", 300000);

  /// Storage ///

  /// Search ///

  // Search via address bar
  user_pref("keyword.enabled", true);

  // Enable suggestion of searches; safe since I use SearX
  user_pref("browser.search.suggest.enabled", true);
  user_pref("browser.urlbar.suggest.searches", true);

  /// Search ///


  /// Misc ///

  // Disable letterboxing
  user_pref("privacy.resistFingerprinting.letterboxing", false);

  // Enable WebAssembly
  user_pref("javascript.options.wasm", true);

  /// Misc ///
#+END_SRC
*** Themes
**** MaterialFox
#+BEGIN_SRC js :tangle .mozilla/firefox/materialfox.js
  /// MaterialFox ///

  user_pref("toolkit.legacyUserProfileCustomizations.stylesheets", true);
  user_pref("svg.context-properties.content.enabled", true);
  user_pref("browser.tabs.tabClipWidth", 83);
  user_pref("materialFox.reduceTabOverflow", true);
  user_pref("security.insecure_connection_text.enabled", true);

  /// MaterialFox ///
#+END_SRC
**** GNOME
#+BEGIN_SRC js :tangle .mozilla/firefox/gnome.js
  /// GNOME ///

  /* user.js
   ,* https://github.com/rafaelmardojai/firefox-gnome-theme/
   ,*/

  // Enable customChrome.css
  user_pref("toolkit.legacyUserProfileCustomizations.stylesheets", true);

  // Enable CSD
  user_pref("browser.tabs.drawInTitlebar", true);

  // Set UI density to normal
  user_pref("browser.uidensity", 0);

  /// GNOME ///
#+END_SRC
** Setup
Functions:
- =createWorkDir=: checks if the work directory already
  exists, removes it if it does exist (which it will, in
  case non-zero termination of the script), to start afresh.
- =fetchGHacksJS=: fetches the source from upstream and
  navigates into the folder
- =mkTweaks=: makes the custom user.js tweaks according to the
  option passed. Currently, supported themes are /MaterialFox/
  and /GNOME/.
- =applyToProfiles=: reads =profiles.ini= and creates the
  specified profiles, thereafter copying the modified
  user.js files into those profiles.
- =cleanUp=: removes the created work directory.

This script sets up my firefox profiles and custom userJS that
builds upon the GHacksUserJS.
#+BEGIN_SRC sh :tangle .mozilla/firefox/setup.sh
  #!/usr/bin/env bash

  # import sanity
  set -euo pipefail

  # global declarations
  SCRIPT_PATH=$(dirname $(realpath "${BASH_SOURCE}"))

  mkWorkDir() {
      if [[ -d "${SCRIPT_PATH}"/workdir ]]; then
          rm -rf "${SCRIPT_PATH}"/workdir
      fi

      echo "Creating Work Directory..."
      mkdir -p "${SCRIPT_PATH}"/workdir
  }

  fetchGHacksJS() {
      echo "Fetching ghacks user.js..."
      git clone https://github.com/ghacksuserjs/ghacks-user.js.git "${SCRIPT_PATH}"/workdir/ghjs 2>/dev/null 1>&2
  }

  mkTweaks() {
      cp "${SCRIPT_PATH}"/*.js "${SCRIPT_PATH}"/workdir/ghjs

      echo "Applying userchrome tweaks..."
      case "${1}" in
          -m | --materialFox)
              cat "${SCRIPT_PATH}"/workdir/ghjs/materialfox.js >> "${SCRIPT_PATH}"/workdir/ghjs/user-overrides.js
              ;;
          -g | --gnome)
              cat "${SCRIPT_PATH}"/workdir/ghjs/gnome.js >> "${SCRIPT_PATH}"/workdir/ghjs/user-overrides.js
              ;;
          -n | --none)
              ;;
          -h | --help)
              echo -ne "\\nFirefox UserJS helper:
                                   -g, --gnome: apply GNOME userchrome theme
                                   -h, --help: display this message
                                   -m, --materialFox: apply MaterialFox userchrome theme
                                   -n, --none: no theme\\n"
              ;;
          ,*)
              echo -ne "\\nInvalid flag. Pass -h or --help for usage.\\n"
              exit 1
      esac

      echo "Merging tweaks with ghacks user.js..."
      "${SCRIPT_PATH}"/workdir/ghjs/updater.sh -s 2>/dev/null 1>&2
  }

  updateUserJS() {
      mkWorkDir
      fetchGHacksJS
      mkTweaks -n
  }

  applyUserJS() {
      profileList=$(cat "${SCRIPT_PATH}"/profiles.ini | grep -i 'Name' | cut -d '=' -f 2 | awk '{print tolower($0)}')

      for profile in ${profileList}; do
          echo "-> Copying user.js to profile: ${profile}..."
          cp "${SCRIPT_PATH}"/workdir/ghjs/user.js "${HOME}/.config/firefox/${profile}"
      done
  }

  createProfilesINIDir() {
      mkdir -p "${HOME}/.mozilla/firefox"
  }

  applyProfilesINI() {
      ln -sf "${SCRIPT_PATH}"/profiles.ini "${HOME}/.mozilla/firefox/"
  }

  createProfiles() {
      profileList=$(cat "${SCRIPT_PATH}"/profiles.ini | grep -i 'Name' | cut -d '=' -f 2 | awk '{print tolower($0)}')

      echo "Making profile directories..."
      for profile in ${profileList}; do
          mkdir -p "${HOME}/.config/firefox/${profile}"
      done
  }

  applyPolicies() {
      echo "Copying policies.json (may need root permissions)..."

      if [[ -d /usr/lib/firefox ]]; then
          sudo ln -sf "${SCRIPT_PATH}"/policies.json /usr/lib/firefox/distribution
      elif [[ -d /opt/firefox-nightly ]]; then
          sudo chown -R ${USER}:${USER} /opt/firefox-nightly
          ln -sf "${SCRIPT_PATH}"/policies.json /opt/firefox-nightly/distribution
      elif [[ -d /opt/firefox-developer-edition ]]; then
          ln -sf "${SCRIPT_PATH}"/policies.json /opt/firefox-developer-edition/distribution
      elif [[ -d /opt/firefox-beta ]]; then
          ln -sf "${SCRIPT_PATH}"/policies.json /opt/firefox-beta/distribution
      elif [[ -d /usr/lib/firefox-developer-edition ]]; then
          sudo ln -sf "${SCRIPT_PATH}"/policies.json /usr/lib/firefox-developer-edition/distribution
      fi
  }

  cleanUp() {
      echo "Cleaning up after myself..."
      rm -rf "${SCRIPT_PATH}"/workdir
  }

  startFirefox() {
      $(command -v firefox) --ProfileManager 2> /dev/null || \
      $(command -v firefox-developer-edition) --ProfileManager 2> /dev/null || \
      $(command -v firefox-beta) --ProfileManager 2> /dev/null

      echo "Firefox is setup and started. Have a good day!"
  }
#+END_SRC
* Plasma
** Environment
#+BEGIN_SRC sh :tangle .config/plasma-workspace/env/askpass.sh :shebang "#!/usr/bin/env bash"
  export SSH_ASKPASS="$(command -v ksshaskpass)"
  export GIT_ASKPASS="$(command -v ksshaskpass)"
#+END_SRC
** PAM
#+BEGIN_SRC conf :tangle .pam_environment
  SSH_AUTH_SOCK DEFAULT="${XDG_RUNTIME_DIR}/ssh-agent.socket"
#+END_SRC
* Systemd
** SSH Agent
#+BEGIN_SRC conf :tangle .config/systemd/user/ssh-agent.service
  [Unit]
  Description=SSH key agent

  [Service]
  Type=simple
  Environment=SSH_AUTH_SOCK=%t/ssh-agent.socket
  ExecStart=/usr/bin/ssh-agent -D -a $SSH_AUTH_SOCK

  [Install]
  WantedBy=default.target
#+END_SRC
* Thunderbird
** Profiles
This reads the same as the profiles section of Firefox.
#+BEGIN_SRC ini :tangle .thunderbird/profiles.ini
  [General]
  StartWithLastProfile=1

  [Profile0]
  Name=Primary
  IsRelative=1
  Path=../.config/thunderbird/primary
  Default=1
#+END_SRC
* Ungoogled Chromium
** Environment Variables
From Debian bug tracker:
#+begin_quote
As can be seen in the upstream discussion, this happens whenever mesa
drivers are used since threads are used in their GLSL shader
implementation.  This does have a consequence, chromium's GPU driver
will not be sandboxed.  You can see this in about:gpu.

Also seen upstream, it should be possible to work around the problem
by setting MESA_GLSL_CACHE_DISABLE=true.

Best wishes,
Mike
#+end_quote

#+BEGIN_SRC text
  MESA_GLSL_CACHE_DISABLE=true
#+END_SRC
** Flags
A better explanation can be found [[https://peter.sh/experiments/chromium-command-line-switches/][here]].
#+BEGIN_SRC conf :tangle .config/chromium-flags.conf
  # Disable workarounds for various GPU driver bugs.
  # --disable-gpu-driver-bug-workarounds
  # Enable hardware acceleration
  --enable-accelerated-mjpeg-decode
  --enable-accelerated-video
  --enable-gpu-rasterization
  --enable-native-gpu-memory-buffers
  --enable-zero-copy
  --ignore-gpu-blacklist
  # Disables the crash reporting.
  --disable-breakpad
  # Disables cloud backup feature.
  --disable-cloud-import
  # Disables installation of default apps on first run. This is used during automated testing.
  --disable-default-apps
  # Disables the new Google favicon server for fetching favicons for Most Likely tiles on the New Tab Page.
  --disable-ntp-most-likely-favicons-from-server
  # Disables showing popular sites on the NTP.
  --disable-ntp-popular-sites
  # Disable auto-reload of error pages if offline.
  --disable-offline-auto-reload
  # Disables sign-in promo.
  --disable-signin-promo
  # The "disable" flag for kEnableSingleClickAutofill.
  --disable-single-click-autofill
  # Disables syncing browser data to a Google Account.
  --disable-sync
  # Disables the default browser check. Useful for UI/browser tests where we want to avoid having the default browser info-bar displayed.
  --no-default-browser-check
  # Don't send hyperlink auditing pings.
  --no-pings
  # Enable Dark Mode
  --force-dark-mode
  --enable-features=WebUIDarkMode
#+END_SRC
* Scripts
A crontab entry (as root, wherever needed) can be added to automate periodic builds / runs.

A few guidelines followed throughout these scripts:
- Output is silenced and is replaced by friendly messages.
- Errors are handled explicitly instead of letting the script fail.
- Each task is divided into functions, no matter how small.
  The main function looks like nothing more than a series of steps (function calls).
- Documentation for what the function does and why is provided.
- A =$SCRIPT_PATH= is defined to determine the path of the each script.
** General
*** Ungoogled Chromium Extension Updater
- =USER_DATA_DIR= is your data directory for Chromium.
  Normally, it is $HOME/.config/chromium. However since I
  sync my chromium profiles using Nextcloud and only use it
  for web applications; I like to keep it separated from the
  default installation.
- =EXT_DIR= is the directory where extensions are stored.
- =EXTID_LIST= is the list of all extensions you have
  installed currently. The list is fetched from the data
  directory, excluding the /Temp/ directory.
- =CHROMIUM_VERSION= fetches the major version of chromium
  that is installed.

For this function to work, you must set
=chrome://flags/#extension-mime-request-handling= to /Always
prompt for install/ for automatic prompts. A truly
unattended way of updating extensions is not possible at
this moment.
#+BEGIN_SRC sh :tangle .local/bin/ceu :shebang "#!/usr/bin/env bash"
  # import sanity
  set -euo pipefail

  # global declarations
  USER_DATA_DIR="${HOME}/.config/chromium/Apps"
  EXT_DIR="${USER_DATA_DIR}/Default/Extensions"
  EXTID_LIST=$(ls -1 "${EXT_DIR}" | grep -v Temp)
  CHROMIUM_VERSION=$($(command -v chromium) --version | grep -o '\s[0-9][0-9]\.[0-9]' | tr -d ' ')

  printDetails() {
      echo -e "Your Chromium version is ${CHROMIUM_VERSION}.\nYour profile is located at ${USER_DATA_DIR}."
  }

  checkForUpdate() {
      if [[ $((10#${1})) -gt $((10#${2})) ]]; then
          return 0
      else
          return 1
      fi
  }

  installExtension() {
      $(command -v chromium) --user-data-dir="${USER_DATA_DIR}" "${1}"
  }

  main() {
      printDetails

      for extID in ${EXTID_LIST}; do
          UPDATE_URL="https://clients2.google.com/service/update2/crx?response=redirect&acceptformat=crx2,crx3&prodversion=${CHROMIUM_VERSION}&x=id%3D${extID}%26installsource%3Dondemand%26uc"

          if [[ -n $(ls -1 "${EXT_DIR}/${extID}") ]]; then
              oldVersion=$(ls -1 "${EXT_DIR}/${extID}" | tail -1 | sed 's/\.//g; s/\_//g')
              newVersion=$(curl -s "${UPDATE_URL}" | grep --only extension_[0-9]*_[0-9]*_[0-9]*.*.crx | sed -e 's/extension_//g; s/\.crx//g; s/\.//g; s/\_//g')

              if checkForUpdate "${newVersion}" "${oldVersion}"; then
                  installExtension "${UPDATE_URL}"
              fi
          else
              installExtension "${UPDATE_URL}"
          fi
      done
  }

  main "${@}"
#+END_SRC
*** Wallpaper Index
Variables:
- =WALL_STORAGE_PATH= holds the location where the indexed
  wallpapers are kept. Default value is
  =$HOME/Pictures/Wallpapers/Wallhaven= (expected to change in
  the future).
- =WALL_TEMP_PATH= holds the location where the wallpapers
  are downloaded or wherever they are kept unorganized.
  Default value is $HOME/Downloads.

Functions:
- =changeWallStoragePath= prompts for a new location for
  =WALL_STORAGE_PATH= and proceeds normally if
  - the response is any of "y", "Y", "yes", "YES", etc and the entered path exists
  - the response is any of "n", "N", "no", "NO", etc
  In case of an invalid response, the prompt is shown again.
- =changeWallTempPath= is exactly the same as
  =changeWallStoragePath= but for =WALL_TEMP_PATH=.
- =rename= does the following:
  - reads the last index from =WALL_STORAGE_PATH= and
    wallpaper list from =WALL_TEMP_PATH=
  - runs through the list of wallpapers, separates extension
    from name in order to preserve it in the renamed file
  - renames files with a message saying so
  - updates the index after each rename
- =main=, unless either of "-s" or "--silent" is passed,
  proceeds to invoke all functions.
#+BEGIN_SRC sh :tangle .local/bin/wali :shebang "#!/usr/bin/env bash"
  # import sanity
  set -euo pipefail

  # global declarations
  SCRIPT_PATH=$(dirname $(realpath "$0"))
  WALL_STORAGE_PATH="${HOME}/Pictures/Wallpapers/Wallhaven"
  WALL_TEMP_PATH="${HOME}/Downloads"

  changeWallStoragePath() {
      while true; do
          echo -ne "Wallpapers storage path is currently set to ${WALL_STORAGE_PATH}. Do you want to change it? "
          read -r resp

          echo
          case "${resp}" in
              [yY]|[yY][eE][Ss])
                  echo -ne "Please enter a path for wallpaper storage: "
                  read -r WALL_STORAGE_PATH

                  echo
                  if [[ ! -d "${WALL_STORAGE_PATH}" ]]; then
                      echo "You've entered a path that does not exist."
                      continue
                  else
                      break
                  fi
                  ;;
              [nN]|[nN][oO])
                  break
                  ;;
              ,*)
                  echo -e "Invalid response."
                  continue
          esac
      done
  }

  changeWallTempPath() {
      while true; do
          echo -ne "Wallpapers temporary storage path is currently set to ${WALL_TEMP_PATH}. Do you want to change it? "
          read -r resp

          echo
          case "${resp}" in
              [yY]|[yY][eE][Ss])
                  echo -ne "Please enter a path for wallpaper storage: "
                  read -r WALL_TEMP_PATH

                  echo
                  if [[ ! -d "${WALL_TEMP_PATH}" ]]; then
                      echo "You've entered a path that does not exist."
                      continue
                  else
                      break
                  fi
                  ;;
              [nN]|[nN][oO])
                  break
                  ;;
              ,*)
                  echo -e "Invalid response."
                  continue
          esac
      done
  }

  rename() {
      lastIndex=$(ls -1 --sort=version "${WALL_STORAGE_PATH}" | grep -E '^[0-9]+\.[a-z]+$' | tail -1 | cut -d '.' -f1)
      wallList=$(ls -1 --sort=time "${WALL_TEMP_PATH}" | grep -E '^[wW]allhaven.*')

      echo -e "Renaming wallpapers..."
      for wall in ${wallList}; do
          ext=$(echo "${wall}" | cut -d '.' -f2)
          if mv "${WALL_TEMP_PATH}/${wall}" "${WALL_STORAGE_PATH}/$((lastIndex + 1)).${ext}"; then
              echo -e "${WALL_TEMP_PATH}/${wall} has been renamed to ${WALL_STORAGE_PATH}/$((lastIndex + 1)).${ext}"
          else
              echo -e "File ${WALL_TEMP_PATH}/${wall} could not be renamed."
              exit 1
          fi

          lastIndex="$((lastIndex + 1))"
      done
  }

  main() {
      set +u
      case "${1}" in
          "-s"|"--silent")
              rename 1>/dev/null 2>&1
              ;;
      esac
      set -u

      changeWallStoragePath
      changeWallTempPath
      rename
  }

  main
#+END_SRC
** TODO Helpers                                                 :documentation:
*** Bash Sanity
Bash has some very /meme/worthy behaviour by default. The
other day somebody on Reddit was crying because he
accidentally deleted all files in his root directory because:
1. His script did not terminate when a command failed.
2. The failing command's purpose was to assign a base path
   to a variable.

And this happens every other day to some shell beginner out
there. Hence, this script tries to restore sanity to shell
scripts.

- =errexit= terminates the script immediately if a command
  returns a non-zero exit code. It can be temporary bypassed
  by appending a =|| true= which makes the complete command
  exit with zero.
- =pipefail= terminates the script immediately if /part/ of
  the pipe chain exits with a non-zero code.
- =nounset= ensures all variables have been assigned a value
  before they are referred. Upon encountering an empty
  variable, terminates the script. =VAR== is a valid
  assignment.
#+BEGIN_SRC sh :tangle .local/bin/helper
  # Bash Sanity
  # https://kvz.io/blog/2013/11/21/bash-best-practices/
  # https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
  # Exit script if a command fails
  # Use: cmd || true to bypass
  set -o errexit # aka: set -e
  # Exit script if the left side of a pipe fails
  set -o pipefail
  # Exit if a variable is used but not assigned
  set -o nounset # aka: set -u
  # DEBUG MODE
  # Show output of statements as they are being executed
  # set -o xtrace # aka: set -x
#+END_SRC
*** Run Script
=run()= is a wrapper around eval which itself takes args, concatenates them and
runs the concatenated string as a command. Any form of output is silenced. If
=eval= succeeds, a tick mark is displayed and if it doesn't, a cross mark is
displayed. An =exit= has to explicitly stated and =set -o errexit=
#+BEGIN_SRC sh :tangle .local/bin/helper
  run() {
      if eval "${@}" 2>/dev/null 1>&2; then
          printf '\u2714\n'
      else
          printf '\u274c\n'
          exit 1
      fi
  }
#+END_SRC
*** Fetch Source
This function fetches the source from the given URL and displays a tick or cross
mark depending on exit code.
#+BEGIN_SRC sh :tangle .local/bin/helper
  # global declarations
  export SCRIPT_PATH=$(dirname $(realpath "$0"))

  fetchSource() {
      export URL="${1}"
      export REPO_NAME=$(echo "${URL}" | cut -d '/' -f5 | cut -d '.' -f1)

      if [[ -d "${SCRIPT_PATH}/${REPO_NAME}" ]]; then
          cleanUp
      fi

      echo -ne "Fetching source..."
      run git clone --quiet "${URL}" "${SCRIPT_PATH}/${REPO_NAME}"
  }
#+END_SRC
*** Cleanup
#+BEGIN_SRC sh :tangle .local/bin/helper
  cleanUp() {
      echo -ne "Cleaning up all the cruft..."

      run rm -rf "${SCRIPT_PATH}/${REPO_NAME}"
  }
#+END_SRC
** Plasma
*** Virtual Desktop Bar (KDE)
- =fetchSource= gets the latest master from github and
  places it in a subdirectory.
- =installDeps= installs the missing dependencies required
  for building virtual desktop bar.
- =buildTarget= executes a list of commands as mentioned on
  the github page for building the widget.
- =installTarget= runs =make install= to copy the built
  target into the appropriate plasma directory.
- Lastly, =cleanUp= removes the downloaded source.
#+BEGIN_SRC sh :tangle .local/bin/vdb :shebang "#!/usr/bin/env bash"
  # import sanity
  set -euo pipefail

  # global declarations
  SCRIPT_PATH=$(dirname $(realpath "$0"))
  URL="https://github.com/wsdfhjxc/virtual-desktop-bar.git"

  fetchSource() {
      echo -e "Fetching source..."
      if git clone --quiet "${URL}" "${SCRIPT_PATH}"/virtual-desktop-bar; then
          echo -e "\t-> Source fetched successfully."
      else
          echo -e "\t-> Source couldn't be fetched."
      fi
  }

  installDeps() {
      echo -e "Installing dependencies (if any)..."

      if sudo pacman --sync --noconfirm --needed cmake extra-cmake-modules gcc 1> /dev/null 2>&1; then
          echo -e "\t-> Installed all required dependencies."
      else
          echo -e "\t-> All dependencies could not be installed!"
      fi
  }

  buildTarget() {
      cd "${SCRIPT_PATH}"/virtual-desktop-bar
      mkdir -p "${SCRIPT_PATH}"/virtual-desktop-bar/build
      cd "${SCRIPT_PATH}"/virtual-desktop-bar/build

      echo -e "Generating configuration..."
      if cmake "${SCRIPT_PATH}"/virtual-desktop-bar 1> /dev/null 2>&1; then
          echo -e "\t-> Configuration generated."
      else
          echo -e "\t-> Configuration generation failed!"
      fi

      echo -e "Building Virtual Desktop Bar..."
      if make -j$(nproc) 1> /dev/null; then
          echo -e "\t-> Building successful."
      else
          echo -e "\t-> Building failed!"
      fi
  }

  installTarget() {
      cd "${SCRIPT_PATH}"/virtual-desktop-bar/build

      echo -e "Installing target (need root permissions)..."
      if sudo make install 1> /dev/null 2>&1; then
          echo -e "\t-> Installing successful."
      else
          echo -e "\t-> Installing failed!"
      fi
  }

  cleanUp() {
      echo -e "Cleaning up all the cruft..."
      rm -rf "${SCRIPT_PATH}"/virtual-desktop-bar
  }

  main() {
      if [[ -d "${SCRIPT_PATH}"/virtual-desktop-bar ]]; then
          cleanUp
      fi

      fetchSource
      installDeps
      buildTarget
      installTarget
      cleanUp
  }

  main
#+END_SRC
*** KWin Tiling Script (Faho)
Mostly the same as /Virtual Desktop Bar/ sans the building.
The quirk here is to symlink a =.desktop= file for the gooey
configuration section to appear.

There is also an update step which is necessary if the
script has been previously installed.
#+BEGIN_SRC sh :tangle .local/bin/kwts :shebang "#!/usr/bin/env bash"
  # import sanity
  set -euo pipefail

  # global declarations
  SCRIPT_PATH=$(dirname $(realpath "$0"))
  URL="https://github.com/kwin-scripts/kwin-tiling.git"

  fetchSource() {
      echo -e "Fetching source..."
      if git clone --quiet "${URL}" "${SCRIPT_PATH}"/kwin-tiling; then
          echo -e "\t-> Source fetched successfully."
      else
          echo -e "\t-> Source couldn't be fetched."
      fi
  }

  installScript() {
      echo -e "Installing KWin Tiling Script..."
      if plasmapkg2 --type kwinscript --install "${SCRIPT_PATH}"/kwin-tiling 1>/dev/null 2>&1; then
          echo -e "\t-> Installation successful."
      else
          echo -e "\t-> Installation failed!"
      fi
  }

  updateScript() {
      echo -e "Updating KWin Tiling Script..."
      if plasmapkg2 --type kwinscript --upgrade "${SCRIPT_PATH}"/kwin-tiling 1> /dev/null 2>&1; then
          echo -e "\t-> Update successful."
      else
          echo -e "\t-> Update failed!"
      fi
  }

  fixConf() {
      # necessary for configuration option in KWin Scripts menu
      mkdir -p "${HOME}"/.local/share/kservices5
      ln -sf "${HOME}"/.local/share/kwin/scripts/kwin-script-tiling/metadata.desktop "${HOME}"/.local/share/kservices5/kwin-script-tiling.desktop
  }

  cleanUp() {
      echo -e "Cleaning up all the cruft..."
      rm -rf "${SCRIPT_PATH}"/kwin-tiling
  }

  main() {
      if [[ -d "${SCRIPT_PATH}"/kwin-tiling ]]; then
          cleanUp
      fi

      fetchSource
      if [[ -d /home/kayg/.local/share/kwin/scripts/kwin-script-tiling ]]; then
          updateScript
      else
          installScript
      fi

      fixConf
      cleanUp
  }

  main
#+END_SRC
** TODO Spotify                                                 :documentation:
*** WM Name
Spotify treats Linux as a second-class citizen. Everybody knows that. We're glad
to at least have a client, right? But that does not mean the community can't fix
problems that can be fixed. When Spotify starts, it does not set $WM_CLASS which
becomes a problem for window managers if a custom layout or custom changes are
to be defined for that particular window. A simple fix was provided [[https://github.com/dasJ/spotifywm][here]] (hasn't
been updated in years but still works).

#+BEGIN_SRC sh :tangle .local/bin/wmn :shebang "#!/usr/bin/env bash"
  export SCRIPT_PATH=$(dirname $(realpath "$0"))

  buildLibrary() {
      cd "${SCRIPT_PATH}/spotifywm"

      echo -ne "Building library..."
      run make -j$(nproc)
  }

  moveLibrary() {
     echo -ne "Moving built library to /usr/lib (need root permissions)...\nEnter password, please: "
     run sudo --prompt="" mv "${SCRIPT_PATH}/spotifywm/spotifywm.so" /usr/lib
  }

  fixSpotify() {
      echo -ne "Moving desktop file to local directory to make above changes..."
      run cp /usr/share/applications/spotify.desktop "${HOME}"/.local/share/applications

      echo -ne "Making changes in the desktop file..."
      run "sed -Ei 's/^Exec=(.*)/Exec=LD_PRELOAD=\/usr\/lib\/spotifywm.so \1/g' "${HOME}"/.local/share/applications/spotify.desktop"
  }

  main() {
      source "${SCRIPT_PATH}/helper"

      fetchSource "https://github.com/dasJ/spotifywm"
      buildLibrary
      moveLibrary
      fixSpotify
      cleanUp
  }

  main
#+END_SRC
*** Lyrics
One of the things I miss from Deezer is the seamless integration of lyrics (for
a select few songs, at least) into the app / webapp itself. I hear the same
worked for Spotify a few years ago but they lost the license for lyrics with
their lyrics provider / partner. So I found [[https://github.com/SwagLyrics/SwagLyrics-For-Spotify][this]] which queries the song title
from the running Spotify app, fetches lyrics and opens an issue on Github
automatically if it can't find those lyrics. Pretty cool, right?

#+BEGIN_SRC sh :tangle .local/bin/lyr :shebang "#!/usr/bin/env bash"
  # global declarations
  export SCRIPT_PATH=$(dirname $(realpath "$0"))

  checkDeps() {
      echo -ne "Checking for existence of python..."
      run command -v python

      echo -ne "Checking for existence of pip..."
      run command -v pip
  }

  installSL() {
      echo -ne "Installing SwagLyrics if it does not already exist..."
      run $(command -v pip) install --user swaglyrics
  }

  main() {
      source "${SCRIPT_PATH}/helper"

      checkDeps
      installSL
  }

  main
#+END_SRC

*** Theme
#+BEGIN_SRC sh :tangle .local/bin/lyr :shebang "#!/usr/bin/env bash"
  # global declarations
  export SCRIPT_PATH=$(dirname $(realpath "$0"))

  checkSpicetify() {
      echo -ne "Checking if Spicetify exists... "
      run command -v spicetify
  }
#+END_SRC
* ZSH
** Oh-my-zsh stuff
Settings specific to OMZ.
#+BEGIN_SRC sh :tangle .zshrc
  # Path to oh-my-zsh installation.
  export ZSH="${HOME}/.config/omz"

  # Set OMZ theme
  ZSH_THEME="agnoster"

  # _ and - will be interchangeable.
  HYPHEN_INSENSITIVE="true"

  # Enable command auto-correction.
  ENABLE_CORRECTION="true"

  # Display red dots whilst waiting for completion.
  COMPLETION_WAITING_DOTS="true"

  # Too many plugins slow down shell startup.
  # Plugins can be found in $ZSH/plugins
  plugins=(
      copyfile
      git
      vi-mode
      z
      zsh-syntax-highlighting
      zsh-autosuggestions
  )

  source "${ZSH}"/oh-my-zsh.sh
#+END_SRC
** Functions
*** Weather
Fetches the current weather from wttr.in, assumes my city
unless specified otherwise.
#+BEGIN_SRC sh :tangle .zshrc
  wttr() {
      curl https://wttr.in/${1:-Bhubaneswar}
  }
#+END_SRC
** Variables
#+BEGIN_SRC sh :tangle .zshrc
  # PATH
  export PATH="${HOME}/.emacs.d/bin:${HOME}/.local/bin:${PATH}"

  # GO
  export GOPATH="${HOME}/.go"
  export GOBIN="${HOME}/.local/bin"

  # ZSH
  # Fetch suggestions asynchronously
  export ZSH_AUTOSUGGEST_USE_ASYNC=1
  # order of strategies to try
  export ZSH_AUTOSUGGEST_STRATEGY=(
      match_prev_cmd
      completion
  )
  # Avoid autosuggestions for buffers that are too large
  export ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
#+END_SRC
** Aliases
#+BEGIN_SRC sh :tangle .zshrc
  if command -v kitty 2>/dev/null 1>&2; then
      alias icat="kitty +kitten icat"
  fi

  alias vim='emacsclient -nw'
#+END_SRC
** Source
#+BEGIN_SRC sh :tangle .zshrc
  if [[ -f /usr/share/nvm/init-nvm.sh ]]; then
      source /usr/share/nvm/init-nvm.sh
  fi
#+END_SRC
